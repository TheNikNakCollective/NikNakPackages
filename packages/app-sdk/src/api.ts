/* tslint:disable */
/* eslint-disable */
/**
 * @niknak/app
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.14
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
    DUMMY_BASE_URL,
    assertParamExists,
    setApiKeyToObject,
    setBasicAuthToObject,
    setBearerAuthToObject,
    setOAuthToObject,
    setSearchParams,
    serializeDataIfNeeded,
    toPathString,
    createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import {
    BASE_PATH,
    COLLECTION_FORMATS,
    BaseAPI,
    RequiredError,
    operationServerMap,
} from './base'

/**
 * The subject\'s followers whom you also follow
 * @export
 * @interface KnownFollowers
 */
export interface KnownFollowers {
    [key: string]: any

    /**
     *
     * @type {number}
     * @memberof KnownFollowers
     */
    count: number
    /**
     *
     * @type {Array<ProfileViewBasic>}
     * @memberof KnownFollowers
     */
    followers: Array<ProfileViewBasic>
}
/**
 * Metadata tag on an atproto resource (eg, repo or record).
 * @export
 * @interface Label
 */
export interface Label {
    [key: string]: any

    /**
     * The AT Protocol version of the label object.
     * @type {number}
     * @memberof Label
     */
    ver?: number
    /**
     * DID of the actor who created this label.
     * @type {string}
     * @memberof Label
     */
    src: string
    /**
     * AT URI of the record, repository (account), or other resource that this label applies to.
     * @type {string}
     * @memberof Label
     */
    uri: string
    /**
     * Optionally, CID specifying the specific version of \'uri\' resource this label applies to.
     * @type {string}
     * @memberof Label
     */
    cid?: string
    /**
     * The short string name of the value or type of this label.
     * @type {string}
     * @memberof Label
     */
    val: string
    /**
     * If true, this is a negation label, overwriting a previous label.
     * @type {boolean}
     * @memberof Label
     */
    neg?: boolean
    /**
     * Timestamp when this label was created.
     * @type {string}
     * @memberof Label
     */
    cts: string
    /**
     * Timestamp at which this label expires (no longer applies).
     * @type {string}
     * @memberof Label
     */
    exp?: string
    /**
     * A typed array of 8-bit unsigned integer values. The contents are initialized to 0. If the requested number of bytes could not be allocated an exception is raised.
     * @type {object}
     * @memberof Label
     */
    sig?: object
}
/**
 *
 * @export
 * @interface ListPurpose
 */
export interface ListPurpose {}
/**
 *
 * @export
 * @interface ListViewBasic
 */
export interface ListViewBasic {
    [key: string]: any

    /**
     *
     * @type {string}
     * @memberof ListViewBasic
     */
    uri: string
    /**
     *
     * @type {string}
     * @memberof ListViewBasic
     */
    cid: string
    /**
     *
     * @type {string}
     * @memberof ListViewBasic
     */
    name: string
    /**
     *
     * @type {ListPurpose}
     * @memberof ListViewBasic
     */
    purpose: ListPurpose
    /**
     *
     * @type {string}
     * @memberof ListViewBasic
     */
    avatar?: string
    /**
     *
     * @type {number}
     * @memberof ListViewBasic
     */
    listItemCount?: number
    /**
     *
     * @type {Array<Label>}
     * @memberof ListViewBasic
     */
    labels?: Array<Label>
    /**
     *
     * @type {ListViewerState}
     * @memberof ListViewBasic
     */
    viewer?: ListViewerState
    /**
     *
     * @type {string}
     * @memberof ListViewBasic
     */
    indexedAt?: string
}
/**
 *
 * @export
 * @interface ListViewerState
 */
export interface ListViewerState {
    [key: string]: any

    /**
     *
     * @type {boolean}
     * @memberof ListViewerState
     */
    muted?: boolean
    /**
     *
     * @type {string}
     * @memberof ListViewerState
     */
    blocked?: string
}
/**
 *
 * @export
 * @interface LoginBody
 */
export interface LoginBody {
    /**
     *
     * @type {string}
     * @memberof LoginBody
     */
    handle: string
}
/**
 *
 * @export
 * @interface LoginURL
 */
export interface LoginURL {
    /**
     *
     * @type {string}
     * @memberof LoginURL
     */
    url: string
}
/**
 *
 * @export
 * @interface LogoutResponse
 */
export interface LogoutResponse {
    /**
     *
     * @type {string}
     * @memberof LogoutResponse
     */
    message: string
}
/**
 *
 * @export
 * @interface Main
 */
export interface Main {
    [key: string]: any

    /**
     *
     * @type {string}
     * @memberof Main
     */
    uri: string
    /**
     *
     * @type {string}
     * @memberof Main
     */
    cid: string
}
/**
 *
 * @export
 * @interface ProfileAssociated
 */
export interface ProfileAssociated {
    [key: string]: any

    /**
     *
     * @type {number}
     * @memberof ProfileAssociated
     */
    lists?: number
    /**
     *
     * @type {number}
     * @memberof ProfileAssociated
     */
    feedgens?: number
    /**
     *
     * @type {number}
     * @memberof ProfileAssociated
     */
    starterPacks?: number
    /**
     *
     * @type {boolean}
     * @memberof ProfileAssociated
     */
    labeler?: boolean
    /**
     *
     * @type {ProfileAssociatedChat}
     * @memberof ProfileAssociated
     */
    chat?: ProfileAssociatedChat
}
/**
 *
 * @export
 * @interface ProfileAssociatedChat
 */
export interface ProfileAssociatedChat {
    [key: string]: any

    /**
     *
     * @type {ProfileAssociatedChatAllowIncoming}
     * @memberof ProfileAssociatedChat
     */
    allowIncoming: ProfileAssociatedChatAllowIncoming
}
/**
 *
 * @export
 * @interface ProfileAssociatedChatAllowIncoming
 */
export interface ProfileAssociatedChatAllowIncoming {}
/**
 *
 * @export
 * @interface ProfileViewBasic
 */
export interface ProfileViewBasic {
    [key: string]: any

    /**
     *
     * @type {string}
     * @memberof ProfileViewBasic
     */
    did: string
    /**
     *
     * @type {string}
     * @memberof ProfileViewBasic
     */
    handle: string
    /**
     *
     * @type {string}
     * @memberof ProfileViewBasic
     */
    displayName?: string
    /**
     *
     * @type {string}
     * @memberof ProfileViewBasic
     */
    avatar?: string
    /**
     *
     * @type {ProfileAssociated}
     * @memberof ProfileViewBasic
     */
    associated?: ProfileAssociated
    /**
     *
     * @type {ViewerState}
     * @memberof ProfileViewBasic
     */
    viewer?: ViewerState
    /**
     *
     * @type {Array<Label>}
     * @memberof ProfileViewBasic
     */
    labels?: Array<Label>
    /**
     *
     * @type {string}
     * @memberof ProfileViewBasic
     */
    createdAt?: string
}
/**
 *
 * @export
 * @interface ProfileViewDetailed
 */
export interface ProfileViewDetailed {
    [key: string]: any

    /**
     *
     * @type {string}
     * @memberof ProfileViewDetailed
     */
    did: string
    /**
     *
     * @type {string}
     * @memberof ProfileViewDetailed
     */
    handle: string
    /**
     *
     * @type {string}
     * @memberof ProfileViewDetailed
     */
    displayName?: string
    /**
     *
     * @type {string}
     * @memberof ProfileViewDetailed
     */
    description?: string
    /**
     *
     * @type {string}
     * @memberof ProfileViewDetailed
     */
    avatar?: string
    /**
     *
     * @type {string}
     * @memberof ProfileViewDetailed
     */
    banner?: string
    /**
     *
     * @type {number}
     * @memberof ProfileViewDetailed
     */
    followersCount?: number
    /**
     *
     * @type {number}
     * @memberof ProfileViewDetailed
     */
    followsCount?: number
    /**
     *
     * @type {number}
     * @memberof ProfileViewDetailed
     */
    postsCount?: number
    /**
     *
     * @type {ProfileAssociated}
     * @memberof ProfileViewDetailed
     */
    associated?: ProfileAssociated
    /**
     *
     * @type {StarterPackViewBasic}
     * @memberof ProfileViewDetailed
     */
    joinedViaStarterPack?: StarterPackViewBasic
    /**
     *
     * @type {string}
     * @memberof ProfileViewDetailed
     */
    indexedAt?: string
    /**
     *
     * @type {string}
     * @memberof ProfileViewDetailed
     */
    createdAt?: string
    /**
     *
     * @type {ViewerState}
     * @memberof ProfileViewDetailed
     */
    viewer?: ViewerState
    /**
     *
     * @type {Array<Label>}
     * @memberof ProfileViewDetailed
     */
    labels?: Array<Label>
    /**
     *
     * @type {Main}
     * @memberof ProfileViewDetailed
     */
    pinnedPost?: Main
}
/**
 *
 * @export
 * @interface StarterPackViewBasic
 */
export interface StarterPackViewBasic {
    [key: string]: any

    /**
     *
     * @type {string}
     * @memberof StarterPackViewBasic
     */
    uri: string
    /**
     *
     * @type {string}
     * @memberof StarterPackViewBasic
     */
    cid: string
    /**
     *
     * @type {object}
     * @memberof StarterPackViewBasic
     */
    record: object
    /**
     *
     * @type {ProfileViewBasic}
     * @memberof StarterPackViewBasic
     */
    creator: ProfileViewBasic
    /**
     *
     * @type {number}
     * @memberof StarterPackViewBasic
     */
    listItemCount?: number
    /**
     *
     * @type {number}
     * @memberof StarterPackViewBasic
     */
    joinedWeekCount?: number
    /**
     *
     * @type {number}
     * @memberof StarterPackViewBasic
     */
    joinedAllTimeCount?: number
    /**
     *
     * @type {Array<Label>}
     * @memberof StarterPackViewBasic
     */
    labels?: Array<Label>
    /**
     *
     * @type {string}
     * @memberof StarterPackViewBasic
     */
    indexedAt: string
}
/**
 * Metadata about the requesting account\'s relationship with the subject account. Only has meaningful content for authed requests.
 * @export
 * @interface ViewerState
 */
export interface ViewerState {
    [key: string]: any

    /**
     *
     * @type {boolean}
     * @memberof ViewerState
     */
    muted?: boolean
    /**
     *
     * @type {ListViewBasic}
     * @memberof ViewerState
     */
    mutedByList?: ListViewBasic
    /**
     *
     * @type {boolean}
     * @memberof ViewerState
     */
    blockedBy?: boolean
    /**
     *
     * @type {string}
     * @memberof ViewerState
     */
    blocking?: string
    /**
     *
     * @type {ListViewBasic}
     * @memberof ViewerState
     */
    blockingByList?: ListViewBasic
    /**
     *
     * @type {string}
     * @memberof ViewerState
     */
    following?: string
    /**
     *
     * @type {string}
     * @memberof ViewerState
     */
    followedBy?: string
    /**
     *
     * @type {KnownFollowers}
     * @memberof ViewerState
     */
    knownFollowers?: KnownFollowers
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
    configuration?: Configuration
) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback: async (
            options: RawAxiosRequestConfig = {}
        ): Promise<RequestArgs> => {
            const localVarPath = `/oauth/callback`
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthcheck: async (
            options: RawAxiosRequestConfig = {}
        ): Promise<RequestArgs> => {
            const localVarPath = `/healthcheck`
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         *
         * @param {LoginBody} loginBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (
            loginBody: LoginBody,
            options: RawAxiosRequestConfig = {}
        ): Promise<RequestArgs> => {
            // verify required parameter 'loginBody' is not null or undefined
            assertParamExists('login', 'loginBody', loginBody)
            const localVarPath = `/oauth/login`
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            localVarHeaderParameter['Content-Type'] = 'application/json'

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }
            localVarRequestOptions.data = serializeDataIfNeeded(
                loginBody,
                localVarRequestOptions,
                configuration
            )

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (
            options: RawAxiosRequestConfig = {}
        ): Promise<RequestArgs> => {
            const localVarPath = `/oauth/logout`
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfo: async (
            options: RawAxiosRequestConfig = {}
        ): Promise<RequestArgs> => {
            const localVarPath = `/oauth/userinfo`
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
    }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callback(
            options?: RawAxiosRequestConfig
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.callback(options)
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0
            const localVarOperationServerBasePath =
                operationServerMap['DefaultApi.callback']?.[
                    localVarOperationServerIndex
                ]?.url
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath)
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthcheck(
            options?: RawAxiosRequestConfig
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.healthcheck(options)
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0
            const localVarOperationServerBasePath =
                operationServerMap['DefaultApi.healthcheck']?.[
                    localVarOperationServerIndex
                ]?.url
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath)
        },
        /**
         *
         * @param {LoginBody} loginBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(
            loginBody: LoginBody,
            options?: RawAxiosRequestConfig
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginURL>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(
                loginBody,
                options
            )
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0
            const localVarOperationServerBasePath =
                operationServerMap['DefaultApi.login']?.[
                    localVarOperationServerIndex
                ]?.url
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath)
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(
            options?: RawAxiosRequestConfig
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string
            ) => AxiosPromise<LogoutResponse>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.logout(options)
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0
            const localVarOperationServerBasePath =
                operationServerMap['DefaultApi.logout']?.[
                    localVarOperationServerIndex
                ]?.url
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath)
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userinfo(
            options?: RawAxiosRequestConfig
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string
            ) => AxiosPromise<ProfileViewDetailed>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.userinfo(options)
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0
            const localVarOperationServerBasePath =
                operationServerMap['DefaultApi.userinfo']?.[
                    localVarOperationServerIndex
                ]?.url
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath)
        },
    }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance
) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp
                .callback(options)
                .then((request) => request(axios, basePath))
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthcheck(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp
                .healthcheck(options)
                .then((request) => request(axios, basePath))
        },
        /**
         *
         * @param {LoginBody} loginBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(
            loginBody: LoginBody,
            options?: RawAxiosRequestConfig
        ): AxiosPromise<LoginURL> {
            return localVarFp
                .login(loginBody, options)
                .then((request) => request(axios, basePath))
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: RawAxiosRequestConfig): AxiosPromise<LogoutResponse> {
            return localVarFp
                .logout(options)
                .then((request) => request(axios, basePath))
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfo(
            options?: RawAxiosRequestConfig
        ): AxiosPromise<ProfileViewDetailed> {
            return localVarFp
                .userinfo(options)
                .then((request) => request(axios, basePath))
        },
    }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public callback(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration)
            .callback(options)
            .then((request) => request(this.axios, this.basePath))
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public healthcheck(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration)
            .healthcheck(options)
            .then((request) => request(this.axios, this.basePath))
    }

    /**
     *
     * @param {LoginBody} loginBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public login(loginBody: LoginBody, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration)
            .login(loginBody, options)
            .then((request) => request(this.axios, this.basePath))
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logout(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration)
            .logout(options)
            .then((request) => request(this.axios, this.basePath))
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userinfo(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration)
            .userinfo(options)
            .then((request) => request(this.axios, this.basePath))
    }
}
